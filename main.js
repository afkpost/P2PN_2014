// Generated by CoffeeScript 1.6.3
(function() {
  var addPeer, args, constants, debug, details, dev, doPing, doPong, dummy, hello, ifaces, knownPeers, knows, os, printKnownPeers, same, self, server, xmlrpc, _i, _len, _ref;

  require('array-sugar');

  xmlrpc = require('xmlrpc');

  constants = require('./constants');

  os = require('os');

  debug = true;

  args = process.argv.slice(2);

  self = {};

  self.port = parseInt(args[0]) || 8080;

  self.capacity = parseInt(args[1]) || 5;

  ifaces = os.networkInterfaces();

  for (dev in ifaces) {
    _ref = ifaces[dev];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      details = _ref[_i];
      if (details.family === "IPv4" && !details.internal) {
        self.host = details.address;
      }
    }
  }

  knownPeers = [];

  same = function(p1, p2) {
    return p1.host === p2.host && p1.port === p2.port;
  };

  knows = function(peer) {
    return (knownPeers.findOne(function(p) {
      return same(p, peer);
    })) != null;
  };

  addPeer = function(peer) {
    if ((same(peer, self)) || (knows(peer))) {
      return;
    }
    return knownPeers.push(peer);
  };

  dummy = function(err) {};

  doPong = function(details) {
    var client;
    if (debug) {
      console.log("ponging %s:%s", details.host, details.port);
    }
    client = xmlrpc.createClient(details);
    return client.methodCall(constants.PONG, [self, knownPeers], dummy);
  };

  doPing = function(details) {
    var client;
    if (debug) {
      console.log("pinging %s:%s", details.host, details.port);
    }
    client = xmlrpc.createClient(details);
    return client.methodCall(constants.PING, [self], dummy);
  };

  printKnownPeers = function() {
    var peer, _j, _len1, _results;
    console.log("Known peers");
    _results = [];
    for (_j = 0, _len1 = knownPeers.length; _j < _len1; _j++) {
      peer = knownPeers[_j];
      _results.push(console.log(peer.host + ":" + peer.port));
    }
    return _results;
  };

  server = xmlrpc.createServer(self);

  server.on(constants.PING, function(err, _arg, callback) {
    var peer;
    peer = _arg[0];
    callback();
    doPong(peer);
    return addPeer(peer);
  });

  server.on(constants.PONG, function(err, _arg, callback) {
    var peer, peers, sender, _j, _len1, _results;
    sender = _arg[0], peers = _arg[1];
    callback();
    addPeer(sender);
    _results = [];
    for (_j = 0, _len1 = peers.length; _j < _len1; _j++) {
      peer = peers[_j];
      if (!knows(peer && peer !== self)) {
        _results.push(doPing(peer));
      }
    }
    return _results;
  });

  console.log("Listening on %s:%s", self.host, self.port);

  hello = function(address) {
    var host, peer, port, _j, _len1, _ref1, _results;
    if (address) {
      _ref1 = address.trim().split(":"), host = _ref1[0], port = _ref1[1];
      return doPing({
        host: host,
        port: port
      });
    } else {
      _results = [];
      for (_j = 0, _len1 = knownPeers.length; _j < _len1; _j++) {
        peer = knownPeers[_j];
        _results.push(doPing(peer));
      }
      return _results;
    }
  };

  process.stdout.write("> ");

  process.stdin.resume();

  process.stdin.setEncoding("utf8");

  process.stdin.on("data", function(data) {
    var address, command, _ref1;
    _ref1 = data.split(" "), command = _ref1[0], address = _ref1[1];
    command = command.trim();
    switch (command) {
      case constants.HELLO:
        hello(address);
        break;
      case constants.PLIST:
        printKnownPeers();
        break;
      default:
        console.log("unknown command: " + command);
    }
    return process.stdout.write("> ");
  });

}).call(this);
